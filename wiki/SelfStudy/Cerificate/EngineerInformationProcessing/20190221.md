### 전자계산기구조

---

* 바이트 머신의 데이터 형식

  * 부동소수점 데이터

    * 지수 : 
    * 가수

    ``실수는 보통 정수부와 소수부로 나누지만, 부동 소수점 방식은 가수부와 지수부로 나누어 표현한다``

* 마이크로 오퍼레이션 : 내부 연산 조건

  * ADD 명령어
    * 누적한다 : 즉 "+"

* 모듈러스-14 카운터 : 0부터 13까지 구별할 수 있다.

  ``플립플롭: 1비트 기억 소자``

  * Modulo-n 카운터에 필요한 플립플롭의 수 : log2N

* SDRAM (S : 싱크, 동기)

  * 정의 :
    * 쿨록속도가 CPU와 동기화되어 있는 DRAM의 다양한 종류를 모두 일컫는다.
    * CPU가 작동할 때 D램도 따라 움직여서 CPU가 수행할 수 있는 명령어의 개수를 증가시켜서 속도 를 향상,
  * 동작
    * 여러 개의 내부 뱅크들에서 동시 액세스가 진행된다.
    * 버스 클럭에 동기화되어 정보가 전송된다.
    * 여러 개의 데이터들을 연속으로 전송하는 버스트 모드를 지원한다.

* 캐시 : CPU와 주기억장치의 속도 차이를 극복하기 위해 존재 하는 메모리

  * 미스율 : 캐시에 없는 횟수 / 기억장치 총 접근 횟수
  * hit : 캐시에 있을 때

* 입출력장치 : 외부장치

  * 인터럽트
    * 우선순위
      * 하드웨어적으로 결정하는 방식
        * Daisy Chain

* 레지스터

  * 범용 레지스터 : 
  * 플래그 레지스터
  * 인덱스 레지스터
  * 세그먼트 레지스터 : 시스템 프로그램상에서 접근이 가능
    * 세그먼트의 영역을에 대한 주소를 저장하는 공간
    * 16비트(2바이트) 크기의 레지스터 6개로 구성되어있다.

* 인스트럭션(명령어)의 설계 과정

  * 고려해야 할 사항
    * 데이터 구조
    * 연산자의 수와 종류
    * 주소지정 방식
    * 명령어 형식 

* DMA(다이렉트 메모리 에세스) : CPU독립접(직접)

* 소형계산기에서 BCD코드 대신 excess-3 코드를 많이 사용하는 가장 큰 이유

  * 자기 보수가 가능하다

* 인터럽트의 우선순위결정과 가장 관계 없는 것

  * 트랩방식 !
  * 폴링 방식
  * 벡터 방식
  * 데이지 체인 방식

* 세그먼트

  * 파이프라인
    * 파이프라인에 의한 이론적 최대 속도 증가율 = 세그먼트의 수
    * k세그먼트 파이프라인에서 n 태스크를 완료시 클럭 사이 클 : k + (n-1)

* 부호화

  * N가지의 정보를 2진수 코드로 부호화 하는데 필요한 비트를 계싼하는 방법으로 옳은 것은

    ---> n가지를 표현하는데 필요한 bit 수 

* 병렬 가산기
  * Carry Lookahead Addr
    * 출력 캐리를 미리 예측 및 처리하여 리플캐리지연을 제거한 가산기
      * ``캐리 : 올림``
* 마이크로 명령어 형식
  * 영역
    * 조건 필드 : 조건 플래그를 지정한다.
    * 연산 필드 : 2개인 경우 2개의 마이크로 연산이 동시에 수행된다.
    * 주소 필드 : 분기가 발생할 경우 목적지 마이크로 명령어 주소로 사용된다.
    * 분기 필드 : 분기의 종류와 다음에 실행할 마이크로명령어의 주소를 결정하는 방법 명시한다.
* 1주소 명령
  * 마이크로명령어 MUL A를 가장 바르게 표현한 것은? MUL : 곱셈
  * 1주소가 사용하는 거 : 누산기

* CPU
  * DMA제어기가 받는 정보 (CPU로부터)
    * I/O 장치의 주소
    * 연산 지정자
    * 전송될 데이터 단어들의 수
* AND 마이크로 동작과 가장 유사한 것 : mask동작
* OR 마이크로  유사 : Selective-Set
* XOR 유사 : Compare 연산
* 캐시
  * 메모리의 기록정책
    * write-though : 쓰기 동작이 캐시와 주기억장치에서 동시에 모두 갱신
    * write-back : 새로운 데이터가 캐시에서만 갱신
    * write-once : 최초기록시는 write-though방식이고, 이후부터는 write-back방식을 사용
    * write-all : 한번에