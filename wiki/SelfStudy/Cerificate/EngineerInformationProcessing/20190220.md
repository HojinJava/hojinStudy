### 데이터베이스 

---

* 릴레이션 
  * 용어
    * 차수(디그리) : 속성 (컬럼의 수)
    * 카디널리티(튜플) : row
  * 개념
    * 제약조건
      * 참조 물결성 : 외래키
      * 보안 무결성
      * 개체 무결성 : Null, 중복 값을 가질 수 없다. (기본 키)
      * 정보 무결성
* 색인 순차 파일 ( indexed sequential file)
  * 일반적인 구성 (영역)
    * Index area : 색인
    * Prime area : 기본
    * Overflow area 
* 데이터베이스 설계
  * 순서
    * 개념 설계 -> 논리 설계 -> 물리적 설계
      * 개념 설계
      * 논리적 설계
        * 목표 DBMS에 맞는 스키마 설계
      * 물리적 설계 : 직접 DB에 매칭되는 설계
        * 저장 레코드 양식 설계
        * 레코드 집중의 분석 및 설계
        * 접근 경로 설계
* 트리
  * 용어
    * 차수 (디그리 : 폭, 넓이 ) :   각 노드는 차수를 가지고 있으며, 트리에서 가장 큰 차수의 값이 트리의 차수라 함
* 관계형 데이터베이스
  * 키
    * 후보키 : 유일성 O, 최소성 O --> 하나 선택하면 기본키
    * 대체키 : 기본키를 대체하는 키
    * 슈퍼키 : 유일성 O, 최소성 X
    * 외래키
* 병행제어
  * 목적
    * 시스템 활용도를 최대화
    * 데이터베이스 공유도 최대화
    * 데이터베이스의 일관성 유지
    * 사용자에 대한 응답시간 최소화
* 로킹
  * 정의
    * 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그 데이트 항목을 액세스 할 수 없도록 하는 병행제어 기법
    * 로킹 단위가 커지면 로크의 수가 적어 관리가 쉬어이지만, 병행성 수준이 낮아짐
    * 로킹 단위가 작으면 로크의 수가 많이 관리가 어렵고, 오버헤드가 증가하지만 병행성 수진이 높아짐
  * 단위 예제
    * DMBS전체가
    * 테이블
    * 튜플 
* 데이터의 중복으로 인하여 관계연산을 처리할 때 예기치 못한 **곤란한 현상** 이 발생하는 것을 무엇이라 하는가?
  * 이상 : 삽입이상, 삭제 이상, 갱신 이상
* 그래프
  * 방향 그래프
    * 최대 간선 수 (n : 정점의 개수) : n * (n-1)
* 표현법
  * 연산자 위치
    * pretfix  (앞) :  * 3 4
    * inFix(중) : 3 * 4
    * PostFix (뒤) :  3 4 *
      * Stack(스택) 으로 연산 함
* 정규화

  * 정규화 과정 : 릴레이션 분해
    * 1NF -> 2NF : 부분 함수 종속 제거
    * 2NF -> 3NF : 이행적 함수 종속 제거
      * A -> B 이고 B->C 일 때 A->C인 관계를 제거하는 단계
    * 3NF -> BCNF : 
    * BCNF -> 4NF
* 트리

  * 방문 순서 : 컴퓨터 스캐닝 떄문에 노드의 L부터 탐색을 한다. (R부터 탐색하진 못함)
    * Root 기준
      * Preorder : Root L R
      * Inorder : L Root R
      * Postorder : L R Root
* 관계 대수

  * 원하는 릴레이션을 정의하는 방법을 제공하며 **비절차적** 언어이다. (관계 해석) 
  * 원하는 릴레이션을 정의하는 방법을 제공하며 절차적 언어이다.
  * 릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다
  * 일반 집합 연산과 순수 관계 연산으로 구분된다.
    * 일반 집합 연산 : 합집합, 교집합, 차집합
    * 순수 관계 연산 :select, project,  join, 디비전(?)
  * 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다. 
    * 순서를 명시한다 --> 절차적이다.
* 관계 해석 
  * 키워드 : 비절차 무엇을
    * 설명
      * 수학의 프레디킷 해석에 기반을 두고 있다.
      * 관계 데이터 모델의 제안자의 코드가 관계 데이터베이스 적용할 수 있도록 설계하여 제안
      * 튜플 관계해석과 도메인 관계해석이 있다.
* 색인 순차 파일
  * 개념
    * 레코드를 참조할 때 색인을 탐색한 후 색인이 가리키는 포인터를 사용하여 직접 참조할 수 있다.
    * 레코드를 추가 및 삽ㅇ비하는 경우, 파일 전체를 복사할 필요가 없다.
    * 색인 구역은 트랙 색인, 실린더 색인, 마스터 색인 구역으로 구성된다
* 뷰(View) 
  * 키워드 : 논리적, 가상테이블, 보안
    * 설명
      * DBA는 보안 측면에서 뷰를 활용할 수 있다.
      * 뷰 위에 또 다른 뷰를 정으할 수 있다.
      * 뷰의 정의는 ALTER문을 이용하여 변경할 수 없다. (create, drop 밖에 없음)
* 정규화
  * 목적 : 데이터 중복으로 인한 이상현상 제거
    * 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다.
    * 데이터 삽입시 릴레이션 재구성할 필요성을 줄인다.
    * 효과적인 검색 알고리즘을 생성할 수 있다.
* 해싱함수
  * 방식
    * 폴딩법 : 키를 여러 부분으로 나누고 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 삼는 방식 (숫자를 나열한 후 접다는 의미 , 폴딩 : 접다)
  * 종류
    * 제산 방법
    * 중간 제곱 방법
    * 중첩 방법
    * 기수 변환 방법
    * 무작위 방법
    * 계수 분석 방법
* 트랜잭션
  * 특성 : ACID
    * Atomicity (원자성) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 한다. (논리적인 단위)
    * Durability (영속성,지곡성) :트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨
    * Consistency  (일관성) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 한다.
    * Isolation (격리성, 고립성) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 한다.

* 선형구조 vs 비선형
  * 선형 
    * 배열
    * 스택
    * 큐
  * 비선형
    * 트리
    * 그래프
* 힙 정렬
  * 설명
    * 정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법
    * 평균 수행 시간복잡도는 0(nLog n)다.
    * 입력 자료의 레코드를 완전이진트리로 구성한다.
    * 최악의 수행 시간복잡도는 0(2n^4)이다.

* 데이터웨어하우스

  * 연산
    * OLAP 연산의 종류 (온라인 분석처리)
      * roll-up
        * 둘둘 말아서 위로 	올라간다... --> 요약
      * dicing & slicng 
        * 절단 하는 방법
      * pivoting
        * 행과열을 뒤바뀌는 방법
      * drill-down
        * 깊게 내려간다....--> 깊은 세부 분석
  * 종류
    * ROLAP : Relationer(표)
    * MOLAP :Mulit.. 다차원
    * HOLAP : Hybrid.. 위 두개 합친거

  ​	